<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>YueRuo's Blog</title><link href="http://yueruo.github.io/" rel="alternate"></link><link href="http://yueruo.github.io/feeds/ioskai-fa.atom.xml" rel="self"></link><id>http://yueruo.github.io/</id><updated>2013-12-22T13:20:00+01:00</updated><entry><title>iOS中屏蔽父类方法</title><link href="http://yueruo.github.io/iOS-SuperMethodHide.html" rel="alternate"></link><updated>2013-12-22T13:20:00+01:00</updated><author><name>YueRuo</name></author><id>tag:yueruo.github.io,2013-12-22:iOS-SuperMethodHide.html</id><summary type="html">&lt;h4&gt;iOS中屏蔽父类方法&lt;/h4&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;iOS开发中，有时你可能希望屏蔽一些父类的方法，比如说对于单例类，你不希望别人再通过  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="kt"&gt;Class&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;的方式再次创建一个对象。类似JAVA语言中，可以通过覆盖父类的方法，改为private即可使外部无法访问到此方法，那么iOS中如何操作呢？&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;首先对于Objective-C来说，父类的方法永远是对外可见的。换句话说，不可能达到类似JAVA那种的完全的屏蔽一个方法。但是，我们可以通过如下办法来变相达到：&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;对于任意的对象，其自身都有一个doesNotRecognizeSelector方法，当调用时会抛出异常(可以变相的让类不响应此消息)。
所以，我们可以在类似init这种地方，使用：   &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;init&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;self&lt;/span&gt; &lt;span class="n"&gt;doesNotRecognizeSelector&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="k"&gt;@selector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;)];&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;从而在运行时调用此方法时，由于不响应此消息而报错。&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;你也可以使用断言，或自己的打印来给予其他开发者更多的提示，比如下面这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;init&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;NSAssert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;@&amp;quot;this method not available !&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)];&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;br&gt;---若转载请注明出处- YueRuo's Blog - &lt;a href="http://yueruo.github.io"&gt;http://yueruo.github.io&lt;/a&gt; ---&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;最后，给出一个完整的&lt;code&gt;单例&lt;/code&gt;的小demo，并且禁用外部调用init方法来对类进行实例化，假设类名位YRDemoClass。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;@implementation&lt;/span&gt; &lt;span class="nc"&gt;YRDemoClass&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;YRDemoClass&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;instance&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;+&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;YRDemoClass&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;shareDemoClass&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;dispatch_once_t&lt;/span&gt; &lt;span class="n"&gt;onceToken&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;dispatch_once&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;onceToken&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;instance&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;instance&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;YRDemoClass&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="n"&gt;initBySuper&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;});&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;instance&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;init&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="c1"&gt;//禁用外部可见的init方法&lt;/span&gt;
    &lt;span class="n"&gt;NSAssert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;@&amp;quot;this class is Singleton !&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)];&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="k"&gt;-&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;initBySuper&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="c1"&gt;//外部不可见的方法&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;self&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;super&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;//your custom init&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;self&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c1"&gt;//其他的方法等等&lt;/span&gt;
&lt;span class="k"&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="iOS"></category></entry><entry><title>iOS的通用的类序列化</title><link href="http://yueruo.github.io/YRSerializationCategory.html" rel="alternate"></link><updated>2013-12-10T11:20:00+01:00</updated><author><name>YueRuo</name></author><id>tag:yueruo.github.io,2013-12-10:YRSerializationCategory.html</id><summary type="html">&lt;h4&gt;iOS的通用的类序列化&lt;/h4&gt;
&lt;p&gt;对于任何一门语言来说，序列化和反序列化操作都是很重要的部分。在iOS开发当中，经常可能会遇到把某个类处理成可存储的数据，以便之后使用（或者再恢复成之前的对象）。&lt;br /&gt;
&lt;br&gt;---若转载请注明出处- YueRuo's Blog - &lt;a href="http://yueruo.github.io"&gt;http://yueruo.github.io&lt;/a&gt; ---&lt;br&gt; &lt;br /&gt;
这里我直接进入正题，给出三种解决方案：    &lt;/p&gt;
&lt;h6&gt;第一种：使用iOS框架中的NSKeyedArchiver&lt;/h6&gt;
&lt;p&gt;使用这个的教程网上太多了，概括起来就是对需要序列化和反序列化的类实现NSCoding协议的两个方法&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;encodeWithCoder&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NSCoder&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;aCoder&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;initWithCoder&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NSCoder&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;aDecoder&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;之后通过NSKeyedArchiver进行相应的操作即可。优势是比较简单易处理，能满足保存一个对象并恢复的需求，可以指定保存的类型为xml等等。&lt;/p&gt;
&lt;h6&gt;第二种：对需要自定义序列化的类进行特殊处理&lt;/h6&gt;
&lt;p&gt;比如我希望A类能序列化成JSON数据，然后再通过JSONString反序列化回来，这时候上面的那种方式已经满足不了需求了，可以相应的在A类里面添加如&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NSString&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;toJSONString&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;fromJSONString&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后自己去针对性的实现，这种方式总体上是比上面那种要更加灵活，输出格式也可以自己任意定制，简而言之就是根据自己的类针对性的写相应的序列化和反序列化方法。  &lt;br /&gt;
&lt;br&gt;&lt;br&gt;
上面这两种方式都能实现序列化和反序列化，优势是对不同的类很有针对性，缺点也比较明显，每次你需要对一个新的类做序列化和反序列化时，都要自己去手动实现相应的方法才能使用。如果有100个类需要序列化，难道我们要100个类都挨个写一遍么？&lt;br /&gt;
&lt;br&gt;&lt;/p&gt;
&lt;h6&gt;第三种：使用通用的序列化和反序列化方法。&lt;/h6&gt;
&lt;p&gt;所谓通用方法，即一套可以对任意类进行处理的方法。这里我先给出思路，同样是针对性的对类的所有Property进行遍历处理，存储输出为你想要的通用格式。&lt;br /&gt;
可供使用的技术包括Category、KVC、runtime等等。&lt;br /&gt;
&lt;br&gt;&lt;br&gt;&lt;br /&gt;
我开源了自己的通用的序列化和反序列化的Category，供大家研究和学习。 &lt;br /&gt;
&lt;code&gt;能把一个对象转换为NSDictionary，此Dictionary可以被顺利的JSON或其他存储，如NSUserDefaults等。&lt;/code&gt; &lt;br /&gt;
&lt;a href="https://github.com/YueRuo/NSObject-YRSerialization"&gt;https://github.com/YueRuo/NSObject-YRSerialization&lt;/a&gt; &lt;br /&gt;
更具体的使用方法见项目Demo。&lt;/p&gt;
&lt;p&gt;支持：&lt;br /&gt;
复杂的对象模型，不管是继承、嵌套，都可以顺利的遍历完。
不支持：&lt;br /&gt;
链式存储的对象。如A类中有一个Property也是A类。不支持C结构体。
另外对NSValue、NSString、NSSet、NSArray、NSDictionary对象不支持直接转换。这些类也不需要此操作。&lt;/p&gt;</summary><category term="iOS"></category></entry></feed>